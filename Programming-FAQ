
mostly for bttv currently...


Initialisation
==============

Grabbing does'nt work if the bt848 chip can't sync, you'll get errno
== EAGAIN then (Overlay does work and gives snow).  You have to make
sure:

  * The driver uses the correct Video Input (VIDIOCSCHAN)
  * The driver uses the correct TV norm (VIDIOCSCHAN,VIDIOCSTUNER)
  * For TV input: There is some station tuned in.

With VIDIOCGCHAN you can ask for available input channels and
informations about these.


Simple grabbing with mmap()
===========================

With bttv you can mmap() the bttv memory.  There is room for two
frames, therefore you can get 2*BTTV_MAX_FBUF bytes mapped.

	fd = open("/dev/video", ...);
	/* ... initialisation ... */
	map = mmap(0,BTTV_MAX_FBUF*2,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);

Frame 0 starts at map, frame 1 at map+BTTV_MAX_FBUF.

Ok, that's the preparation, now let's start grabbing.  You have to
fill the parameters (size, format, frame) into a struct video_mmap,
and then do

	ioctl(fd,VIDIOCMCAPTURE,&video_mmap);

This instructs the driver to capture a frame.  The ioctl will return
immedantly, the driver will process your request asyncron (interrupt
driven).  If you want to get the result, you have to wait for it using

	ioctl(fd,VIDIOCSYNC,&video_mmap.frame);

If your request is still in progress, the ioctl will block until it is
done.  Otherwise it will return.  That's all, now you have the result
in the mmap()ed area.


Advanced grabbing
=================

The scheme outlined above works fine for single frames.  If you want
do continuous grabbing and keep up with the full frame rate (25 fps
for PAL), it is'nt that simple.  As mentioned above, the driver has
room for two frames.  There is room for two grabbing requests too.

The basic idea for handling full speed is to let work the bttv driver
and the application in parallel.  The application processes the
picture in one of the frames, while the driver captures the next
picture to the other one.  Works this way:

	/* ... initialisation ... */

	ioctl(capture frame 0)

loop:
	ioctl(capture frame 1)
	ioctl(sync    frame 0)
	/*
         * this sync returns if the first request (for frame 0) is done
         * the driver will continue with the next one (for frame 1),
         * while the application can proccess frame 0.  If the
         * application is done, we reuse frame 0 for the next request ...
         */
	ioctl(capture frame 0)
	ioctl(sync    frame 1)
	/*
	 * same procedure, but the other way around: driver captures
         * to frame 0, application proccesses frame 1
	 */
	goto loop;


Pitfalls / driver changes
=========================

video4linux is work-in-progress, and there still some interface
changes from time to time due to design bugs.

One problem is that the TV norm (PAL/NTSC/...) is in struct
video_tuner, not struct video_channel.  That's bad if you have a board
without tuner at all and a PAL video recorder connected to Composite1
and a NTSC Camera to Composite2...
Fixing this required changes in both structs and the VIDIOCSCHAN
ioctl.

Another one is that the VIDIOCSYNC ioctl had no argument at all, newer
versions take the frame number as argument.  The new scheme is more
stable.

The hard-coded frame size (BTTV_MAX_FBUF) is gone in newer versions,
you should use the VIDIOCGMBUF ioctl to figure out the size at runtime.

Happy hacking,

   Gerd

--
Gerd Knorr <kraxel@goldbach.in-berlin.de>
