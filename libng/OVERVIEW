
libng overview
==============


some general notes
------------------

The text below is not a complete reference (yet?), it just tries to
give a overview and explain the design of the library.  Have a look at
grab-ng.h, this is the header file where everything is defined.

If you are looking for some simple sample code check out
webcam/webcam.c.  More complex usages of libng can be found everythere
in the xawtv source code: In src/capture.c for example, where most of
the threaded movie recording code for xawtv+streamer is.

There are two types of structs: Those which carrying some data (like
ng_video_fmt or ng_video_buf) and those which define a interface (like
ng_driver).

The interfaces all have a initialization function which returns a void
pointer as handle.  All other interface functions expect getting that
handle passed in.  The complete state information is kept there.
Global variables are a no-no, the interfaces need to be reentrant (so
you can use multiple instances of them at the same time).


video buffers (struct ng_video_buf)
-----------------------------------

One video buffer holds one frame.  There are some rules for video
frames:

 (1) Multiple instances (threads for example) may hold a pointer to
     the buffer.  The refcount variable is used to keep track of the
     number of references.  If you hand out a pointer to the buffer to
     someone else *and* keep a pointer to the buffer yourself to use
     it later refcount must be increased by one.  If you don't need
     the buffer any more, just free it with ng_release_video_buf().
     That function will take care about count down the reference
     counter and freeing the buffer if refcount is zero.

 (2) The above implies you should not write to ng_video_buf->data
     because another thread might use the image data while you are
     modifying it. Allocate a new buffer and put the new data in there
     instead if you want process the image data. You can use
     ng_malloc_video_buf() to get a buffer.  Don't forget to copy the
     frame meta data to the new buffer (ng_video_buf->info).

Within the current implementation two types of buffers exist: Those
malloc()ed ones which are returned by ng_malloc_video_buf() and
buffers provided by the hardware drivers, where ng_video_buf->data is
a pointer directly to the mmap()ed buffer(s).


video capture / overlay drivers (struct ng_driver)
--------------------------------------------------

This is a interface to a capture driver.  Right now three different
ones exist:

 (1) video4linux (current linux API, see grab-v4l.c).
 (2) video4linux two (work in progress - new API for linux, see
     grab-v4l2.c).
 (3) bktr (bt848/878 driver for FreeBSD + OpenBSD, see grab-bsd.c).

xawtv uses struct ng_driver for Xvideo support too (see src/xv.c).

open()/close() should be clear.  The capabilities() function returns a
bitfield which specifies the capabilities of the driver.  The *attr*
functions can be used to control several (hardware) settings (see
below for more on attributes).

To for a overlay use setupfb() and overlay().  For linux setupfb()
just verifies the driver parameters, it expects the setup is done with
a extern utility like v4l-conf (because one needs root priviliges for
that).

To capture frames you have to configure the format with setformat()
first.  Be aware that the image size might have changed on return,
depending on the capabilities of the underlying hardware.  For video
recording use startvideo(), multiple nextframe() calls and
stopvideo(), for single frames use getimage().


output drivers (struct ng_writer)
---------------------------------

This is a interface for movie writer code.  Four different ones exist:

 (1) Microsoft's AVI
 (2) Apple Quicktime (using the quicktime4linux library).
 (3) raw, uncompressed data (one big file).
 (4) one image file/frame (jpeg or ppm).

The first two write audio and video data into the same stream, the
last two can write audio data to a separate wav file.

The audio/video args hold a list of supported formats.  Usage should
be pretty straight forward: wr_open(), write data with wr_video() +
wr_audio(), then wr_close().  You can write both audio-only and
video-only streams if you want.


attributes (struct ng_attribute)
--------------------------------

Attributes can be used to control properties attributes.  Right now
they are only used for video drivers (struct ng_driver), but that
might change in the future.  There are a number of standard attributes
defined (tv norm, volume and the like), but it is also possible to
specify non-standard attributes.

struct ng_driver has functions to list/read/modify the available
attributes.  A number of helper functions to search a attribute list
by id / name and for multiple choice attribute handling are available
too.


audio
-----

Right now there are only some structs for audio formats and audio data
chunks.  The movie writers use these.  No recording code yet.  xawtv's
audio recording code is in src/oss.c, maybe I move that to libng some
day.  Need to create some sensible interface for it first.


misc
----

There are some helper functions for various stuff, see grab-ng.[ch].
There are also some arrays with text descriptions and other
informations about audio/video formats: ng_[va]fmt_to_*.
